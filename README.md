# CPSC-304

## What is this course about?
This course provides an introduction to Database Management System (DBMS). We focus on the most widely used relational data model. Students will become familiar with the design of database applications and use of databases. We study design tools, database modeling and query languages, including the Structured Query Language (SQL), data warehouses and Data mining. The official course outline can be found here:  https://courses.students.ubc.ca/cs/courseschedule?pname=subjarea&tname=subj-course&dept=CPSC&course=304

## Learning Outcomes
| Topic         | Learning Outcomes            | 
| :---------------- | :-------------- | 
| Introduction to a DBMS | -   Define the term database and explain the purpose of having a database. <br> -  Explain the high-level objectives of a database management system (DBMS), and explain how a DBMS relates to a database. <br> - List benefits that result from the usage of a DBMS.   | 
| Entity Relationship Diagram | - Explain the purpose of an E-R diagram, and explain the differences between entities, attributes, domains, and relationships. <br> -  Describe the different types of keys: search, candidate, primary, alternate, foreign, and super(key). <br> - Explain the types of questions that you would ask a knowledgeable user in order to create a data model (E-R diagram) about a given business process. <br> - Given a problem description, create an E-R diagram with the correct entities and relationships that accurately model the problem’s data. Justify the decisions you make for entities, relationships, keys, key constraints, participation constraints, aggregations, etc. <br> - Given a problem domain/description that contains entities that: depend on other entities, inherit from other entities, or have n-ary relationships with other entities, create an E-R diagram that accurately represents them. Justify your decisions. <br> - Given a problem description, identify alternative representations of the problem, and evaluate the choices. <br> - For a given domain/problem, compare alternative E/R diagrams or techniques, and identify their strengths and weaknesses.  | 
| Relational Model | - Compare and contrast logical and physical data independence. <br> - Define the components (and synonyms) of the relational model: tables, rows, columns, keys, associations, etc. <br> - Create and modify tables, including attributes, keys, field lengths, etc., using Data Definition Language (DDL). <br> -Create a view for a table. Explain the purpose of a view. <br> - Explain and differentiate the kinds of integrity constraints in a database (e.g., primary key constraints). <br> - Explain the purpose of referential integrity. <br> - Enforce referential integrity in a database using DML. Determine which delete, insert, or update policy to use when coding rules/defaults for referential integrity. Analyze the impact that a poor choice has. <br> - Map E-R diagrams to the relational model (i.e., DDL), including constraints, weak entity sets, etc. | 
| Schema Refinement & Normal Forms| -Debate the pros and cons of redundancy in a database. <br> - Explain why functional dependencies (FDs) are a type of integrity constraint.<br> - Provide examples of update, insertion, and deletion anomalies.<br> - List and explain the purpose of Armstrong’s Axioms.<br> - Determine the FDs that exist in a table for a given application. <br> - Prove that an FD can/cannot be derived from a given set of dependencies.<br> - Given a set of tables and a set of functional dependencies over them, determine all the candidate keys for the tables.<br> - Show that a table is/isn’t in a certain normal form: 1NF, 2NF, 3NF, or BCNF. <br> - Prove that a given table decomposition is (is not) lossless join. Justify why lossless join decompositions are preferred decompositions. <br> - Decompose/transform a table into a set of tables that are in 2NF, 3NF, and BCNF. <br> - Argue for or against: Most tables for business applications should be decomposed into BCNF. <br> - Justify why some tables should not be in BCNF. Provide a good example of a set of tables that should not be in BCNF.|
| Relational Algebra| - Explain the purpose of relational algebra (RA). <br> - Identify the basic operators in RA.  <br> - Given a set of tables, express a database query in Relational Algebra, involving the basic operators (selection, projection, cross product, renaming, set union, intersection, difference ), join, division, and assignment.  <br> - Show that RA expressions can often be rewritten to produce the same result (e.g., different orderings of operations, different subsets of operators).  <br> -Determine which of two equivalent RA expressions is likely to be more efficient.  <br> - Show that two RA queries are/aren’t equivalent.  <br> - Given an RA query, table schemas, and instances, compute the result of the query.|
| Datalog| - Given a set of tuples (an input relation) and rules, compute the output relation for a Datalog program. <br> - Write (relatively simple) Datalog programs to query an input relation. <br> - Explain why we want to extend RA or SQL with recursive queries. Provide good examples of such queries.<br> - Explain the importance of safe queries, and what makes a Datalog query safe.|

| SQL| - Given the schemas of a relation, create a simple query in SQL that qualifies the search using WHERE-clause arguments. <br> - Create more complex queries in SQL that join multiple tables. <br> -Create SQL queries that appropriately use the keywords: SELECT, FROM, WHERE, ORDER BY, EXISTS, NOT EXISTS, UNIQUE, NOT UNIQUE, ANY, ALL, and DISTINCT. <br> -Create SQL queries that aggregate data, using the GROUP BY and HAVING clauses.<br> 
|SQLgg| - Given the schemas of a relation, create a simple query in SQL that qualifies the search using WHERE-clause arguments. <br>
-Create more complex queries in SQL that join multiple tables. <br> -Create SQL queries that appropriately use the keywords: SELECT, FROM, WHERE, ORDER BY, EXISTS, NOT EXISTS, UNIQUE, NOT UNIQUE, ANY, ALL, and DISTINCT. <br> -Create SQL queries that aggregate data, using the GROUP BY and HAVING clauses. <br> -Show that there are alternative ways of coding SQL queries to yield the same result. Determine whether or not two SQL queries are equivalent. <br> -Given an SQL query, table schemas, and instances, compute the result of the query. <br> - Create SQL statements that appropriately use the keywords: INSERT, UPDATE, and DELETE. <br> - Translate a query between SQL and RA.<br> -Comment on the relative expressive power of SQL and RA. <br> - Debate the use of NULLs and 3-valued logic to appropriately represent missing attribute values (“unknowns”). Argue that NULLs can be ambiguous in certain contexts. Suggest alternate ways of handling “unknowns” as an alternative to NULLs. <br> - Write embedded SQL for a small-to-medium sized programming application that requires database access (e.g., using Java/JDBC, PHP, ODBC, or a DBMS-specific pre-compiler).|



## Textbook
- Ramakrishnan and Gehrke. Database Management Systems, 3rd Edition, McGraw-Hill, 2003. The 2nd edition is also fine. 

## Additional Reference Material (optional)
If you want additional reference material, any book on relational database systems that has been published in the past few years should be fine.

